################################################################################
# Globals                                                                      #
################################################################################

################################################################################
# Window sizes and visibility                                                  #
################################################################################
position.width=750
position.height=890

split.vertical=0

buffers=26
tabbar.visible=1
tabbar.hide.one=0
statusbar.visible=1

# Sizes and visibility in edit pane
line.margin.visible=1
line.margin.width=4
buffered.draw=1
use.palette=0

################################################################################
# Element styles                                                               #
################################################################################

view.whitespace=0
view.indentation.whitespace=1
view.indentation.guides=1
view.indentation.examine=3
highlight.indentation.guides=1
caret.period=500
caret.fore=#FF00FF
caret.width=3
edge.column=200
edge.mode=0
edge.colour=#C0DCC0
braces.check=1
braces.sloppy=1

selection.alpha=30
selection.back=#000000

################################################################################
# Scripting                                                                    #
################################################################################

#ext.lua.startup.script=$(SciteUserHome)/.scite/SciTEStartup.lua
#ext.lua.auto.reload=1

################################################################################
# Checking                                                                     #
################################################################################
are.you.sure=1
load.on.activate=1
are.you.sure.on.reload=1

################################################################################
# Indentation                                                                  #
################################################################################
tabsize=8
indent.size=4
use.tabs=0
indent.automatic=1
indent.opening=0
indent.closing=0

################################################################################
# Wrapping of long lines
################################################################################
#wrap=1
#wrap.style=2
#output.wrap=1

################################################################################
# Folding                                                                      #
################################################################################
fold=1
fold.compact=1
fold.flags=16
fold.symbols=1
fold.comment=1
fold.preprocessor=1

################################################################################
# Behaviour                                                                    #
################################################################################
#vc.home.key=1
eol.auto=1
clear.before.execute=0
autocompleteword.automatic=1
caret.policy.xslop=1
caret.policy.width=20
caret.policy.xstrict=0
caret.policy.xeven=0
caret.policy.xjumps=0
caret.policy.yslop=1
caret.policy.lines=1
caret.policy.ystrict=1
caret.policy.yeven=1
caret.policy.yjumps=0

################################################################################
# Status Bar                                                                   #
################################################################################
statusbar.number=4
statusbar.text.1=\
L: $(LineNumber)  C: $(ColumnNumber)        $(FilePath) $(OverType) ($(EOLMode))
statusbar.text.2=\
$(BufferLength) chars in $(NbOfLines) lines. Sel: $(SelLength) chars.
statusbar.text.3=\
Now is: Date=$(CurrentDate) Time=$(CurrentTime)
statusbar.text.4=\
$(FileNameExt) : $(FileDate) - $(FileTime) | $(FileAttr)


################################################################################
# Help                                                                         #
################################################################################
command.scite.help=xdg-open "file://$(SciteDefaultHome)/SciTEDoc.html"

################################################################################
# Internationalisation                                                         #
################################################################################
code.page=0
output.code.page=65001

################################################################################
# Export                                                                       #
################################################################################
export.html.wysiwyg=1
export.html.styleused=1
export.pdf.magnification=-3
export.pdf.font=Courier
export.pdf.pagesize=595,842
export.pdf.margins=72,72,72,72
export.xml.collapse.spaces=1
export.xml.collapse.lines=1

################################################################################
# Define values for use in the imported properties files                       #
################################################################################
chars.alpha=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
chars.numeric=0123456789
chars.accented=äöåúüˇ¿‡¡·¬‚√„ƒ‰≈Â∆Ê«Á»Ë…È ÍÀÎÃÏÕÌŒÓœÔ–—Ò“Ú”Û‘Ù’ı÷ÿ¯Ÿ˘⁄˙€˚‹¸›˝ﬁ˛ﬂˆ

################################################################################
# Open files                                                                   #
################################################################################
# The open.filter setting is used in the file selector which has a menu of 
# filters to apply to the types of files seen when opening.
# There is a limit (possibly 256 characters) to the length of a filter 
# on Windows, so not all source extensions can be in this setting.
source.files=*.c;*.cc;*.cpp;*.cxx;*.cs;*.h;*.hh;*.hxx;*.hpp;\
*.java;*.js;*.py;*.pl;*.lua;*.conf;\
make*;*.mak;*.R;*.sh;*.tcsh;*.zsh;*.csh;*.bash;\
*.properties;*.html;*.xml;*.bat;*.m;\
*.tfam;*.tped;*.bim;*.ped;*.fam;*.ls;*.dat*.in;*.out;

# Each platform has a different idea of the most important filters
all.files=All Files (*)|*|Hidden Files (.*)|.*|
top.filters=All Source|$(source.files)|$(all.files)

open.filter=\
$(top.filters)\
$(filter.bash)\
$(filter.cmake)\
$(filter.cpp)\
$(filter.css)\
$(filter.d)\
$(filter.fortran)\
$(filter.java)\
$(filter.js)\
$(filter.lua)\
$(filter.matlab)\
$(filter.pascal)\
$(filter.perl)\
$(filter.php)\
$(filter.properties)\
$(filter.python)\
$(filter.r)\
$(filter.ruby)\
$(filter.tcl)\
$(filter.tex)\
$(filter.text)

#save.filter=$(open.filter)

################################################################################
# Give symbolic names to the set of fonts used in the standard styles.         #
################################################################################

font.base=$(font.monospace)
font.small=font:!Efont Fixed,size:10
font.comment=$(font.monospace)
font.code.comment.box=$(font.comment)
font.code.comment.line=$(font.comment)
font.code.comment.doc=$(font.comment)
font.text=$(font.monospace)
font.text.comment=$(font.monospace)
font.embedded.base=$(font.monospace)
font.embedded.comment=$(font.monospace)
font.monospace=font:!Efont Fixed,size:12
font.vbs=$(font.monospace)
font.js=$(font.comment)

colour.code.comment.box=fore:#1F1F00,back:#EEEEFF
colour.code.comment.line=fore:#1F1F00,back:#EEEEFF
colour.code.comment.doc=fore:#003F3F,back:#FFF0F0
colour.code.comment.nested=fore:#1F1F00,back:#EEEEFF
colour.text.comment=fore:#0000FF,back:#D0F0D0
colour.other.comment=fore:#007F00
colour.embedded.comment=back:#E0EEFF
colour.embedded.js=back:#F0F0FF
colour.notused=back:#FF0000

colour.number=fore:#000000
colour.keyword=fore:#FF8C00
colour.storgetype=fore:#dd2222,back:#ddffff  # storage type
colour.indentifier=fore:#203587
colour.string=fore:#005500,back:#DDFFDD
colour.char=fore:#004400,back:#DDFFDD
colour.operator=fore:#770000
colour.preproc=fore:#7F7F00
colour.error=fore:#FFFF00,back:#FF0000

################################################################################
# Global default styles for all languages                                      #
################################################################################
# Default
style.*.32=$(font.base)
# Line number
style.*.33=back:#E0E0E0,$(font.base)
# Brace highlight
style.*.34=fore:#0000FF,bold
# Brace incomplete highlight
style.*.35=fore:#FF0000,bold
# Control characters
style.*.36=
# Indentation guides
style.*.37=fore:#C0C0C0,back:#FFFFFF

################################################################################
# Define the Lexer menu                                                        #
################################################################################

menu.language=\
Text|txt|$(keyText)|\
&C / C++|c||\
CMake|cmake||\
&Difference|diff||\
&Fortran|f90||\
H&ypertext|html|$(keyHTML)|\
Java|java||\
Lu&a|lua||\
Matlab|m.matlab||\
&Makefile|mak|$(keyMake)|\
Octave|m.octave||\
Pe&rl|pl||\
&Properties|properties||\
Pytho&n|py||\
R|R||\
Shell|sh||\
&TCL|tcl||\
&XML|xml|$(keyXML)|

################################################################################
# User defined key commands                                                    #
################################################################################

################################################################################
# Import all the language specific properties files                            #
################################################################################
# it is not allowed to import the language properties files from different 
# directories. I just append the files here.

########################################
# C++ properties                       #
########################################
# Define SciTE settings for C++, C, C#, Ch, Java, IDL, JavaScript, Flash files.

# sma files are Small script (C-like)

file.patterns.cpp=*.c;*.cc;*.cpp;*.cxx;*.h;*.hh;*.hpp;*.hxx;*.ipp;*.m;*.mm;*.sma
file.patterns.cplusplus=*.cc;*.cpp;*.cxx;*.hpp
# jad = decompiled class files; pde = Processing.org sketch files
file.patterns.java=*.java;*.jad;*.pde
file.patterns.javafx=*.fx
# pln, inc and t are SilkTest (4Test) files.
file.patterns.test=*.pln;*.inc;*.t
# es = JS dialect of Abobe for SVG
file.patterns.js=*.js;*.es
file.patterns.cs=*.cs
file.patterns.ch=*.ch;*.chf;*.chs
file.patterns.vala=*.vala
file.patterns.go=*.go
file.patterns.c.like=$(file.patterns.cpp);$(file.patterns.cs);\
$(file.patterns.idl);$(file.patterns.java);$(file.patterns.js);\
$(file.patterns.flash);$(file.patterns.ch);$(file.patterns.vala)

shbang.tcc=cpp
shbang.tinycc=cpp

filter.cpp=C/C++ (c cc cpp cxx cs vala h hh hxx hpp ipp dlg rc rc2 mak)|\
$(file.patterns.cpp);$(file.patterns.cs);$(file.patterns.rc);\
$(file.patterns.vala);*.mak;make*|
filter.java=Java (java)|*.java|
filter.js=JavaScript (js es)|$(file.patterns.js)|
filter.idl=IDL (idl odl)|$(file.patterns.idl)|
filter.test=SilkTest (pln inc t)|$(file.patterns.test)|
filter.flash=Flash (as asc jsfl)|$(file.patterns.flash)|
filter.ch=Ch (ch chf chs)|$(file.patterns.ch)|
filter.go=Go (go)|$(file.patterns.go)|

lexer.$(file.patterns.java)=cpp
lexer.$(file.patterns.javafx)=cpp
lexer.$(file.patterns.cpp)=cpp
lexer.$(file.patterns.rc)=cpp
lexer.$(file.patterns.idl)=cpp
lexer.$(file.patterns.cs)=cpp
lexer.$(file.patterns.js)=cpp
lexer.$(file.patterns.test)=cpp
lexer.$(file.patterns.flash)=cpp
lexer.$(file.patterns.ch)=cpp
lexer.$(file.patterns.vala)=cpp
lexer.$(file.patterns.go)=cpp

# real keywords
keywordclass.cpp= and and_eq bitand bitor break case catch compl const_cast \
continue default delete do dynamic_cast else false for goto if namespace new \
not not_eq or or_eq reinterpret_cast return sizeof static_cast switch this \
throw true try using while xor xor_eq
keywords.$(file.patterns.cpp)=$(keywordclass.cpp)

# keywords2 is for highlighting user defined keywords or function calls 
# KL: well, now I use it for storage types
keywords2.$(file.patterns.cpp)=class typename typeid template friend virtual \
inline explicit operator public private protected const extern auto register \
static mutable unsigned signed volatile char double float int uint long short \
bool wchar_t size_t string void typedef struct union enum asm export

# keywords3 is for doc comment keywords, highlighted in style 17
#CPP doxygen
file.patterns.doxygen.langs=$(file.patterns.cpp);$(file.patterns.java)
keywordclass.doxygen=a addindex addtogroup anchor arg attention \
author b brief bug c class code date def defgroup deprecated dontinclude \
e em endcode endhtmlonly endif endlatexonly endlink endverbatim enum example \
exception \
f$ f[ f] file fn hideinitializer htmlinclude htmlonly \
if image include ingroup internal invariant interface latexonly li line link \
mainpage name namespace nosubgrouping note overload \
p page par param param[in] param[out] \
post pre ref relates remarks return retval \
sa section see showinitializer since skip skipline struct subsection \
test throw throws todo typedef union until \
var verbatim verbinclude version warning weakgroup $ @ \ & < > # { }
keywords3.$(file.patterns.doxygen.langs)=$(keywordclass.doxygen)

# keywords5 is for preprocessor definitions and will cause inactive code
# to be greyed out. This setting is a space separated list of definitions
# where a definition may be of the form NAME=VALUE or simply NAME.
#keywords5.$(file.patterns.cpp)=_MSC_VER SCI_NAMESPACE GTK_MAJOR_VERSION=2

word.chars.cxx=$(chars.alpha)$(chars.numeric)_#
word.characters.$(file.patterns.cpp)=$(word.chars.cxx)
calltip.cpp.word.characters=$(chars.alpha)$(chars.numeric)_
comment.block.cpp=//
comment.block.at.line.start.cpp=1
comment.stream.start.cpp=/*
comment.stream.end.cpp=*/
comment.box.start.cpp=/*
comment.box.middle.cpp= *
comment.box.end.cpp= */

# Folding
#fold.cpp.syntax.based=0
#fold.cpp.comment.multiline=0
#fold.cpp.comment.explicit=0
#defaults for fold.cpp.explicit.start=//{ and fold.cpp.explicit.end=//}
#  can be replaced by defining custom strings, e.g. //[ and //]
#fold.cpp.explicit.start=//[
#fold.cpp.explicit.end=//]
#if fold strings are set to something like /*{{{ and /*}}} 
#(Origami/WinF style fold strings), enable
#  fold.cpp.explicit.anywhere, allowing explicit fold points being anywhere, 
# not just in line comments
#fold.cpp.explicit.anywhere=1
#fold.at.else=1

word.characters.$(file.patterns.javafx)=$(word.chars.cxx)$-

file.patterns.c.except.cpp=$(file.patterns.cs);$(file.patterns.idl);\
*.java;$(file.patterns.flash);$(file.patterns.ch)
statement.indent.$(file.patterns.c.except.cpp)=5 case default do else for if \
while
statement.indent.$(file.patterns.cpp)=5 case default do else for if private \
protected public while
statement.end.$(file.patterns.c.like)=10 ;
statement.lookback.$(file.patterns.c.like)=20
block.start.$(file.patterns.c.like)=10 {
block.end.$(file.patterns.c.like)=10 }

#autocomplete.cpp.fillups=(

#styling.within.preprocessor=1
preprocessor.symbol.$(file.patterns.cpp)=#
preprocessor.start.$(file.patterns.cpp)=if ifdef ifndef
preprocessor.middle.$(file.patterns.cpp)=else elif
preprocessor.end.$(file.patterns.cpp)=endif

preprocessor.symbol.$(file.patterns.cs)=#
preprocessor.start.$(file.patterns.cs)=if region
preprocessor.middle.$(file.patterns.cs)=else elif
preprocessor.end.$(file.patterns.cs)=endif endregion

keywordclass.ch=\
auto array bool break case char class complex ComplexInf ComplexNaN \
const continue default delete \
do double else enum export extern float for foreach goto if Inf inline int \
long namespace NaN new NULL private public register restrict return short \
signed sizeof static string_t struct switch this typedef union unsigned \
using void volatile wchar_t while __declspec
keywords.$(file.patterns.ch)=$(keywordclass.ch)
word.chars.ch=$(chars.alpha)$(chars.numeric)_#
word.characters.$(file.patterns.ch)=$(word.chars.cxx)
comment.block.ch=//~
#comment.block.at.line.start.ch=1
comment.stream.start.ch=/*
comment.stream.end.ch=*/
comment.box.start.ch=/*
comment.box.middle.ch= *
comment.box.end.ch= */
preprocessor.symbol.$(file.patterns.ch)=#
preprocessor.start.$(file.patterns.ch)=if ifdef ifndef
preprocessor.middle.$(file.patterns.ch)=else elif
preprocessor.end.$(file.patterns.ch)=endif

keywordclass.cs=abstract as ascending base bool break by byte case catch char \
checked class const continue decimal default delegate descending do double \
else enum equals event explicit extern false finally fixed float for foreach \
from goto group if implicit in int interface internal into is join lock let \
long namespace new null object on operator orderby out override params private \
protected public readonly ref return sbyte sealed select short sizeof \
stackalloc static string struct switch this throw true try typeof uint ulong \
unchecked unsafe ushort using var virtual void where while
keywords.$(file.patterns.cs)=$(keywordclass.cs)
word.characters.$(file.patterns.cs)=$(word.chars.cxx)

keywordclass.go=\
bool byte break case chan complex64 complex128 const continue defer default \
else  for func go goto fallthrough false float32 float64 if import int \
interface int8 int16 int32 int64 len map nil package range return select \
string struct switch true type uint uintptr uint8 uint16 uint32 uint64 var
keywords.$(file.patterns.go)=$(keywordclass.go)

keywordclass.rc=\
ACCELERATORS ALT AUTO3STATE AUTOCHECKBOX AUTORADIOBUTTON \
BEGIN BITMAP BLOCK BUTTON CAPTION CHARACTERISTICS CHECKBOX CLASS \
COMBOBOX CONTROL CTEXT CURSOR DEFPUSHBUTTON DIALOG DIALOGEX DISCARDABLE \
EDITTEXT END EXSTYLE FONT GROUPBOX ICON LANGUAGE LISTBOX LTEXT \
MENU MENUEX MENUITEM MESSAGETABLE POPUP \
PUSHBUTTON RADIOBUTTON RCDATA RTEXT SCROLLBAR SEPARATOR SHIFT STATE3 \
STRINGTABLE STYLE TEXTINCLUDE VALUE VERSION VERSIONINFO VIRTKEY
keywords.$(file.patterns.rc)=$(keywordclass.rc)


# http://java.sun.com/docs/books/tutorial/java/nutsandbolts/_keywords.html
keywordclass.java=abstract assert boolean break byte case catch char class \
const continue default do double else enum extends final finally float for \
goto if implements import instanceof int interface long native new package \
private protected public return short static strictfp super switch \
synchronized this throw throws transient try var void volatile while
keywords.$(file.patterns.java)=$(keywordclass.java)

keywordclass.javafx=abstract after and as assert at attribute before bind \
bound break catch class continue def delete else exclusive extends false \
finally for from function if import indexof insert instanceof lazy mod new \
not null or override package private protected public-init public public-read \
return reverse sizeof static super then this throw true try typeof var while
keywords.$(file.patterns.javafx)=$(keywordclass.javafx)
# Base types and global functions (defined in javafx.lang.Builtins 
# and javafx.lang.FX)
# And now language words deprecated from their keyword status...
keywords2.$(file.patterns.javafx)=Boolean Duration Integer Number Object \
String Void Character Byte Short Long Float Double isInitialized isSameObject \
print println first in init into inverse last on postinit replace step trigger \
tween where with
# I don't know what first and last nor trigger do. Neither lazy or typeof...

keywordclass.javascript=abstract boolean break byte case catch char class \
const continue debugger default delete do double else enum export extends \
final finally float for function goto if implements import in instanceof \
int interface long native new package private protected public \
return short static super switch synchronized this throw throws \
transient try typeof var void volatile while with
keywords.$(file.patterns.js)=$(keywordclass.javascript)

keywordclass.vala=if else switch case default break continue return yield for \
foreach in do while try catch finally throw

keywordclass2.vala=namespace interface class struct enum delegate signal \
errordomain construct get set value base const static var dynamic weak unowned \
virtual abstract override public protected private extern throws requires \
ensures yields out ref lock using true false null delete generic new this \
typeof sizeof as owned int string char bool

keywords.$(file.patterns.vala)=$(keywordclass.vala)
keywords2.$(file.patterns.vala)=$(keywordclass2.vala)

#lexer.cpp.track.preprocessor=1
#lexer.cpp.update.preprocessor=1

########################################
# C++ styles                           #
########################################

# Default
style.cpp.32=$(font.base)
# White space
style.cpp.0=fore:#808080
# Comment: /* */.
style.cpp.1=$(colour.code.comment.box),$(font.code.comment.box)
# Line Comment: //.
style.cpp.2=$(colour.code.comment.line),$(font.code.comment.line)
# Doc comment: block comments beginning with /** or /*!
style.cpp.3=$(colour.code.comment.doc),$(font.code.comment.doc)
# Number
style.cpp.4=$(colour.number)
# Keyword
style.cpp.5=$(colour.keyword),bold
# Double quoted string
style.cpp.6=$(colour.string)
# Single quoted string
style.cpp.7=$(colour.char)
# UUIDs (only in IDL)
style.cpp.8=fore:#804080
# Preprocessor
style.cpp.9=$(colour.preproc)
# Operators
style.cpp.10=$(colour.operator),bold
# Identifiers
style.cpp.11=$(colour.indentifier),bold
# End of line where string is not closed
style.cpp.12=fore:#000000,$(font.monospace),back:#E0C0E0,eolfilled
# Verbatim strings for C#
style.cpp.13=fore:#007F00,$(font.monospace),back:#E0FFE0,eolfilled
# Regular expressions for JavaScript
style.cpp.14=fore:#3F7F3F,$(font.monospace),back:#E0F0FF,eolfilled
# Doc Comment Line: line comments beginning with /// or //!.
style.cpp.15=$(colour.code.comment.doc),$(font.code.comment.doc)
# Keywords2, storage types
style.cpp.16=$(colour.storgetype)
# Comment keyword
style.cpp.17=fore:#3060A0,$(font.code.comment.doc)
# Comment keyword error
style.cpp.18=fore:#804020,$(font.code.comment.doc)
# Raw strings for C++0x
style.cpp.20=$(colour.string),back:#FFF3FF,eolfilled
# Triple-quoted strings for Vala
style.cpp.21=$(font.monospace),fore:#007F00,back:#E0FFE0,eolfilled

# Inactive states are 64 greater than their active counterparts

# White space
style.cpp.64=fore:#C0C0C0
# Comment: /* */.
style.cpp.65=$(style.cpp.1),fore:#90B090
# Line Comment: //.
style.cpp.66=$(style.cpp.2),fore:#90B090
# Doc comment: block comments beginning with /** or /*!
style.cpp.67=$(style.cpp.3),fore:#D0D0D0
# Number
style.cpp.68=$(style.cpp.4),fore:#90B0B0
# Keyword
style.cpp.69=$(style.cpp.5),fore:#9090B0
# Double quoted string
style.cpp.70=$(style.cpp.6),fore:#B090B0
# Single quoted string
style.cpp.71=$(style.cpp.7),fore:#B090B0
# UUIDs (only in IDL)
style.cpp.72=$(style.cpp.8),fore:#C0C0C0
# Preprocessor
style.cpp.73=$(style.cpp.9),fore:#B0B090
# Operators
style.cpp.74=$(style.cpp.10),fore:#B0B0B0
# Identifiers
style.cpp.75=$(style.cpp.11),fore:#B0B0B0
# End of line where string is not closed
style.cpp.76=$(style.cpp.12),fore:#000000
# Verbatim strings for C#
style.cpp.77=$(style.cpp.13),fore:#90B090
# Regular expressions for JavaScript
style.cpp.78=$(style.cpp.14),fore:#7FAF7F
# Doc Comment Line: line comments beginning with /// or //!.
style.cpp.79=$(style.cpp.15),fore:#C0C0C0
# Keywords2
style.cpp.80=$(style.cpp.16),fore:#C0C0C0
# Comment keyword
style.cpp.81=$(style.cpp.17),fore:#C0C0C0
# Comment keyword error
style.cpp.82=$(style.cpp.18),fore:#C0C0C0
# Raw strings for C++0x
style.cpp.84=$(style.cpp.20),fore:#B090B0
# Triple-quoted strings for Vala
style.cpp.85=$(style.cpp.21),fore:#90B090


# Braces are only matched in operator style
braces.cpp.style=8

########################################
# C++ compile                          #
########################################

ccopts=-pedantic -Os
cc=g++ $(ccopts) -c $(FileNameExt) -o $(FileName).o
ccc=gcc $(ccopts) -c $(FileNameExt) -o $(FileName).o

make.command=make
command.compile.*.c=$(ccc) -std=c99
command.build.*.c=$(make.command)
command.build.*.h=$(make.command)
command.go.*.c=./$(FileName) > t.out
# To make the Go command both compile (if needed) and execute, use this setting:
#command.go.needs.*.c=gcc $(ccopts) -std=c99 $(FileNameExt) -o $(FileName)

command.compile.$(file.patterns.cplusplus)=$(cc)
command.build.$(file.patterns.cplusplus)=$(make.command)
command.go.$(file.patterns.cplusplus)=./$(FileName) > t.out
command.go.needs.$(file.patterns.cplusplus)=g++ $(ccopts) $(FileNameExt) \
-o $(FileName)

command.name.0.$(file.patterns.cpp)=Indent
command.0.$(file.patterns.cpp)=astyle -taOHUKk3 -M8 $(FileNameExt)
command.is.filter.0.$(file.patterns.cpp)=1

command.name.1.$(file.patterns.cplusplus)=Lint
command.1.$(file.patterns.cplusplus)=g++ -W -Wall -Wshadow -Wwrite-strings \
-Wold-style-cast \
-Woverloaded-virtual -pedantic -Os -fno-exceptions -c $(FileNameExt)

if PLAT_GTK
	command.help.$(file.patterns.cpp)=man $(CurrentWord) | col -b

if PLAT_GTK
	command.build.*.cs=mcs /t:winexe $(FileNameExt) /r:System,System.Drawing
	command.go.*.cs=mono $(FileName).exe
	command.go.subsystem.*.cs=1

command.compile.*.java=javac $(FileNameExt)
command.build.*.java=javac *.java
command.go.*.java=java -cp . $(FileName)

command.compile.*.ch=ch -n $(FileNameExt)
command.build.*.ch=ch -n  $(FileNameExt)
command.go.*.ch=ch -u $(FileNameExt)

command.build.$(file.patterns.vala)=valac $(FileNameExt)
command.go.*.vala=./$(FileName)

# can also be 6g for 64-bit systems!
command.compile.*.go=8g $(FileNameExt)
command.build.*.go=$(make.command)
command.go.*.go=./$(FileName)

################################################################################
# python properties                                                            #
################################################################################
# Define SciTE settings for Python files.

file.patterns.py=*.py;*.pyw
file.patterns.scons=SConstruct;SConscript

shbang.python=py

filter.python=Python (py pyw)|$(file.patterns.py)|

lexer.$(file.patterns.py)=python
lexer.$(file.patterns.scons)=python

keywordclass.python=and as assert break class continue def del elif \
else except exec finally for from global if import in is lambda None \
not or pass print raise return try while with yield

# Extra keywords for cython
keywordclass.cython=cdef cimport cpdef

keywords.$(file.patterns.py)=$(keywordclass.python) $(keywordclass.cython)
keywords.$(file.patterns.scons)=$(keywordclass.python)

#~ statement.indent.$(file.patterns.py)=10 :
statement.indent.$(file.patterns.py)=5 class def elif else except finally \
for if try while with

statement.lookback.$(file.patterns.py)=0
block.start.$(file.patterns.py)=
block.end.$(file.patterns.py)=

view.indentation.examine.*.py=2

tab.timmy.whinge.level=1

#fold.quotes.python=1

comment.block.python=#
comment.block.at.line.start.python=1

indent.python.colon=1

# Python styles
# White space
style.python.0=fore:#808080
# Comment
style.python.1=$(colour.code.comment.line),$(font.comment)
# Number
style.python.2=$(colour.number)
# String
style.python.3=$(colour.string)
# Single quoted string
style.python.4=$(colour.string)
# Keyword
style.python.5=$(colour.keyword),bold
# Triple quotes
style.python.6=$(colour.code.comment.doc),bold
# Triple double quotes
style.python.7=$(colour.code.comment.doc),bold
# Class name definition
style.python.8=$(colour.storgetype),bold
# Function or method name definition
style.python.9=$(colour.indentifier),bold
# Operators
style.python.10=$(colour.operator),bold
# Identifiers
style.python.11=$(colour.indentifier),bold
# Comment-blocks
style.python.12=$(colour.code.comment.line)
# End of line where string is not closed
style.python.13=fore:#000000,$(font.monospace),back:#E0C0E0,eolfilled
# Highlighted identifiers
style.python.14=fore:#407090
# Decorators
style.python.15=fore:#805000
# Matched Operators
style.python.34=fore:#0000FF,bold
style.python.35=fore:#FF0000,bold
# Braces are only matched in operator style
braces.python.style=8

########################################
# python compiler                      #
########################################

command.go.*.py=python3 -u "$(FileNameExt)" > t.out
command.build.SConscript=scons --up .
command.build.SConstruct=scons .

command.help.$(file.patterns.py)=pydoc3 $(CurrentWord) | col -b

command.name.1.*.py=Syntax Check
command.1.*.py=python -c "import py_compile; py_compile.compile(r'$(FilePath)')"

################################################################################
# R properties                                                                 #
################################################################################
# Define SciTE settings for R and S source files

file.patterns.r=*.R;*.rsource;*.S;
file.patterns.r.like=$(file.patterns.r)

filter.r=R and S+ (R S rsouce)|$(file.patterns.r)|

lexer.$(file.patterns.r)=r

keywordclass.r=if else repeat while function for in next break TRUE FALSE NULL \
NA Inf NaN

keywords.$(file.patterns.r)=$(keywordclass.r)


keywords3.$(file.patterns.r)=acme aids aircondit amis aml banking barchart \
barley beaver bigcity boot brambles breslow bs bwplot calcium cane capability \
cav censboot channing city claridge cloth cloud coal condense contourplot \
control corr darwin densityplot dogs dotplot ducks empinf envelope \
environmental ethanol fir frets gpar grav gravity grob hirose histogram islay \
knn larrows levelplot llines logit lpoints lsegments lset ltext lvqinit lvqtest \
manaus melanoma melanoma motor multiedit neuro nitrofen nodal ns nuclear oneway \
parallel paulsen poisons polar qq qqmath remission rfs saddle salinity shingle \
simplex singer somgrid splom stripplot survival tau tmd tsboot tuna unit urine \
viewport wireframe wool xyplot

word.chars.r=$(chars.alpha)$(chars.numeric)_.#
word.characters.$(file.patterns.r)=$(word.chars.r)
comment.block.r=#
comment.block.at.line.start.r=1

statement.indent.$(file.patterns.r.like)=5 for if
statement.end.$(file.patterns.r.like)=10 ;
statement.lookback.$(file.patterns.r.like)=20
block.start.$(file.patterns.r.like)=10 {
block.end.$(file.patterns.r.like)=10 }

# R styles

# Default
style.r.32=$(font.base)
# White space
style.r.0=fore:#808080
# Comment
style.r.1=$(colour.code.comment.box),$(font.code.comment.box)
#Keyword
style.r.2=$(colour.keyword),bold
# Base Package Function
style.r.3=fore:#7f0000,bold
# Other Package Function
style.r.4=fore:#7f007F,bold
# Number
style.r.5=$(colour.number)
# " Delimited String
style.r.6=$(colour.string)
# ' Delimited String
style.r.7=$(colour.string)
# Operator
style.r.8=$(colour.operator),bold
# Identifier
style.r.9=$(colour.identifier)
# INFIX highlight
style.r.10=$(colour.operator),bold
# INFIX End of Line error
style.r.11=$(colour.operator),$(font.monospace),back:#E0C0E0,eolfilled

# Braces are only matched in operator style
braces.r.style=8

command.go.*.r=R --slave < ./$(FileName) > t.out

################################################################################
# shell, awk and perl properties                                               #
################################################################################
# Define SciTE settings for Perl, Bash, and AWK files.

file.patterns.perl=*.pl;*.pm;*.pod
file.patterns.bash=*.sh;*.bsh;configure;*.ksh;*.zsh;*.tcsh
file.patterns.awk=*.awk

shbang.perl=pl
shbang.sh=sh
shbang.bash=sh

shbang.gawk=awk
shbang.nawk=awk
shbang.mawk=awk

filter.perl=Perl (pl pm)|$(file.patterns.perl)|
filter.bash=Bash (sh bsh)|$(file.patterns.bash)|
filter.awk=GAWK  (awk)|$(file.patterns.awk)|

lexer.$(file.patterns.perl)=perl
lexer.$(file.patterns.bash)=bash
lexer.$(file.patterns.awk)=perl

keywords.$(file.patterns.perl)=\
NULL __FILE__ __LINE__ __PACKAGE__ __DATA__ __END__ AUTOLOAD \
BEGIN CORE DESTROY END EQ GE GT INIT LE LT NE CHECK abs accept \
alarm and atan2 bind binmode bless caller chdir chmod chomp chop \
chown chr chroot close closedir cmp connect continue cos crypt \
dbmclose dbmopen defined delete die do dump each else elsif endgrent \
endhostent endnetent endprotoent endpwent endservent eof eq eval \
exec exists exit exp fcntl fileno flock for foreach fork format \
formline ge getc getgrent getgrgid getgrnam gethostbyaddr gethostbyname \
gethostent getlogin getnetbyaddr getnetbyname getnetent getpeername \
getpgrp getppid getpriority getprotobyname getprotobynumber getprotoent \
getpwent getpwnam getpwuid getservbyname getservbyport getservent \
getsockname getsockopt glob gmtime goto grep gt hex if index \
int ioctl join keys kill last lc lcfirst le length link listen \
local localtime lock log lstat lt map mkdir msgctl msgget msgrcv \
msgsnd my ne next no not oct open opendir or ord our pack package \
pipe pop pos print printf prototype push quotemeta qu \
rand read readdir readline readlink readpipe recv redo \
ref rename require reset return reverse rewinddir rindex rmdir \
scalar seek seekdir select semctl semget semop send setgrent \
sethostent setnetent setpgrp setpriority setprotoent setpwent \
setservent setsockopt shift shmctl shmget shmread shmwrite shutdown \
sin sleep socket socketpair sort splice split sprintf sqrt srand \
stat study sub substr symlink syscall sysopen sysread sysseek \
system syswrite tell telldir tie tied time times truncate \
uc ucfirst umask undef unless unlink unpack unshift untie until \
use utime values vec wait waitpid wantarray warn while write \
xor \
given when default break say state UNITCHECK

keywords.$(file.patterns.awk)=\
BEGIN END \
if else while do for in break continue delete exit function return \
print printf sprintf \
system close getline next nextfile fflush \
atan2 cos exp int log rand sin sqrt srand \
asort asorti gensub sub gsub index length match split \
strtonum substr tolower toupper \
mktime strftime systime \
and compl lshift or rshift xor \
bindtextdomain dcgettext dcngettext \
ARGC ARGIND ARGV BINMODE CONVFMT ENVIRON ERRNO FIELDWIDTHS \
FILENAME FNR FS IGNORECASE LINT NF NR OFMT OFS ORS PROCINFO \
RS RT RSTART RLENGTH SUBSEP TEXTDOMAIN


comment.block.awk=#~
block.start.$(file.patterns.awk)=10 {
block.end.$(file.patterns.awk)=10 }


word.characters.$(file.patterns.perl)=$(chars.alpha)$(chars.numeric)_$@%&

comment.block.perl=#~
block.start.$(file.patterns.perl)=10 {
block.end.$(file.patterns.perl)=10 }

colour.perl.heredoc=$(colour.embedded.comment)

#fold.perl.package=1
#fold.perl.pod=1

# generic keywords
bash_keywords1=alias \
ar asa awk banner basename bash bc bdiff break \
bunzip2 bzip2 cal calendar case cat cc cd chmod cksum \
clear cmp col comm compress continue cp cpio crypt \
csplit ctags cut date dc dd declare deroff dev df diff diff3 \
dircmp dirname do done du echo ed egrep elif else env \
esac eval ex exec exit expand export expr false fc \
fgrep fi file find fmt fold for function functions \
getconf getopt getopts grep gres hash head help \
history iconv id if in integer jobs join kill local lc \
let line ln logname look ls m4 mail mailx make \
man mkdir more mt mv newgrp nl nm nohup ntps od \
pack paste patch pathchk pax pcat perl pg pr print \
printf ps pwd read readonly red return rev rm rmdir \
sed select set sh shift size sleep sort spell \
split start stop strings strip stty sum suspend \
sync tail tar tee test then time times touch tr \
trap true tsort tty type typeset ulimit umask unalias \
uname uncompress unexpand uniq unpack unset until \
uudecode uuencode vi vim vpax wait wc whence which \
while who wpaste wstart xargs zcat

# additional keywords from coreutils
bash_keywords2=chgrp chown chroot dir dircolors \
factor groups hostid install link md5sum mkfifo \
mknod nice pinky printenv ptx readlink seq \
sha1sum shred stat su tac unlink users vdir whoami yes

keywords.$(file.patterns.bash)=$(bash_keywords1) $(bash_keywords2)

word.characters.$(file.patterns.bash)=$(chars.alpha)$(chars.numeric)_$@%&

comment.block.bash=#~

colour.bash.heredoc=$(colour.embedded.comment)

# Perl styles
# The perl styles are set to lots of different foreground and background 
# colours as an aid to debugging SciTE's Perl lexer - not because this is a 
# good way to display Perl.
style.perl.32=
# White space
style.perl.0=fore:#808080,$(font.base)
# Error
style.perl.1=$(colour.error)
# Comment
style.perl.2=$(colour.code.comment.box),$(font.code.comment.box)
# POD: = at beginning of line
style.perl.3=fore:#004000,back:#E0FFE0,$(font.text),eolfilled
# Number
style.perl.4=$(colour.number)
# Keyword
style.perl.5=$(colour.keyword),bold
# Double quoted string
style.perl.6=$(colour.string),$(font.monospace)
# Single quoted string
style.perl.7=$(colour.char),$(font.monospace)
# Symbols / Punctuation. Currently not used by LexPerl.
style.perl.8=$(colour.notused),$(font.notused)
# Preprocessor. Currently not used by LexPerl.
style.perl.9=$(colour.notused),$(font.notused)
# Operators
style.perl.10=$(colour.operator),bold
# Identifiers (functions, etc.)
style.perl.11=fore:#000000
# Scalars: $var
style.perl.12=fore:#000000,back:#FFE0E0
# Array: @var
style.perl.13=fore:#000000,back:#FFFFE0
# Hash: %var
style.perl.14=fore:#000000,back:#FFE0FF
# Symbol table: *var
style.perl.15=fore:#000000,back:#E0E0E0
# Regex: /re/ or m{re}
style.perl.17=fore:#000000,back:#A0FFA0
# Substitution: s/re/ore/
style.perl.18=fore:#000000,back:#F0E080
# Long Quote (qq, qr, qw, qx) -- obsolete: replaced by qq, qx, qr, qw
style.perl.19=fore:#FFFF00,back:#8080A0
# Back Ticks
style.perl.20=$(style.perl.6),back:#90FFFF
# Data Section: __DATA__ or __END__ at beginning of line
style.perl.21=fore:#600000,back:#FFF0D8,eolfilled
# Here-doc (delimiter)
style.perl.22=fore:#000000,back:#DDD0DD
# Here-doc (single quoted, q)
style.perl.23=fore:#7F007F,back:#DDD0DD,eolfilled,notbold
# Here-doc (double quoted, qq)
style.perl.24=fore:#7F007F,back:#DDD0DD,eolfilled,bold
# Here-doc (back ticks, qx)
style.perl.25=fore:#7F007F,back:#DDD0DD,eolfilled,italics
# Single quoted string, generic
style.perl.26=fore:#7F007F,$(font.monospace),notbold
# qq = Double quoted string
style.perl.27=$(style.perl.6)
# qx = Back ticks
style.perl.28=$(style.perl.20)
# qr = Regex
style.perl.29=$(style.perl.17)
# qw = Array
style.perl.30=$(style.perl.13)
# POD: verbatim paragraphs
style.perl.31=fore:#004000,back:#C0FFC0,$(font.monospace),eolfilled
# subroutine prototype
style.perl.40=$(style.perl.10),italics
# format identifier
style.perl.41=fore:#C000C0,bold
# format body
style.perl.42=fore:#C000C0,back:#FFF0FF,eolfilled
# translation: tr{}{} y{}{}
style.perl.44=$(style.perl.18)

# Double quoted string (interpolated variable)
style.perl.43=$(style.perl.6),fore:#D00000,bold
# Regex: /re/ or m{re} (interpolated variable)
style.perl.54=$(style.perl.17),fore:#D00000,bold
# Substitution: s/re/ore/ (interpolated variable)
style.perl.55=$(style.perl.18),fore:#D00000,bold
# Back Ticks (interpolated variable)
style.perl.57=$(style.perl.20),fore:#D00000,bold
# Here-doc (double quoted, qq) (interpolated variable)
style.perl.61=$(style.perl.24),fore:#D00000,bold
# Here-doc (back ticks, qx) (interpolated variable)
style.perl.62=$(style.perl.61)
# qq = Double quoted string (interpolated variable)
style.perl.64=$(style.perl.43)
# qx = Back ticks (interpolated variable)
style.perl.65=$(style.perl.57)
# qr = Regex (interpolated variable)
style.perl.66=$(style.perl.54)

# Braces are only matched in operator style
braces.perl.style=10

# Bash styles
# The bash styles are set to lots of different foreground and background 
# colours as an aid to debugging SciTE's Bash lexer - not because this is a 
# good way to display Bash.
style.bash.32=
# White space
style.bash.0=fore:#808080,$(font.base)
# Error
style.bash.1=$(colour.error)
# Comment
style.bash.2=$(colour.code.comment.box),$(font.code.comment.box)
# Number
style.bash.3=$(colour.number)
# Keyword
style.bash.4=$(colour.keyword),bold
# Double quoted string
style.bash.5=$(colour.string),$(font.monospace)
# Single quoted string
style.bash.6=$(colour.char),$(font.monospace)
# Operators
style.bash.7=$(colour.operator),bold
# Identifiers (functions, etc.)
style.bash.8=fore:#000000
# Scalars: $var
style.bash.9=fore:#000000,back:#FFE0E0
# Parameter expansion: ${var}
style.bash.10=fore:#000000,back:#FFFFE0
# Back Ticks
style.bash.11=fore:#FFFF00,back:#A08080
# Here-doc (delimiter)
style.bash.12=fore:#000000,back:#DDD0DD
# Here-doc (single quoted, q)
style.bash.13=fore:#7F007F,back:#DDD0DD,eolfilled,notbold
# Braces are only matched in operator style
braces.bash.style=7

command.go.$(file.patterns.awk)=gawk -f $(FileNameExt)

command.go.$(file.patterns.perl)=perl -w $(FileNameExt)

command.compile.$(file.patterns.perl)=perl -c -w $(FileNameExt)
command.name.0.$(file.patterns.perl)=Lint
command.0.$(file.patterns.perl)=perl -MO=Lint,all $(FileNameExt)

command.name.1.$(file.patterns.perl)=Check Syntax
command.1.$(file.patterns.perl)=perl -cw $(FileNameExt)

command.name.2.$(file.patterns.perl)=Code Profiler
command.2.$(file.patterns.perl)=perl -d:DProf $(FileNameExt)

command.name.3.$(file.patterns.perl)=Profiler Parser
command.3.$(file.patterns.perl)=C:\Perl\bin\dprofpp.bat $(FileDir)\tmon.out

################################################################################
# fortran properties                                                           #
################################################################################
# Define SciTE settings for Fortran files.

filter.fortran=Fortran (f for f90 f95 f2k)|*.f;*.for;*.f90;*.f95;*.f2k|

file.patterns.f95=*.f90;*.f95;*.f2k
file.patterns.f77=*.f;*.for
file.patterns.fortran=$(file.patterns.f95);$(file.patterns.f77)

lexer.$(file.patterns.f95)=fortran
lexer.$(file.patterns.f77)=f77

# keywords and input/output specifiers
keywordclass.fortran=access action advance allocatable allocate \
apostrophe assign assignment associate asynchronous backspace \
bind blank blockdata call case character class close common \
complex contains continue cycle data deallocate decimal delim \
default dimension direct do dowhile double doubleprecision else \
elseif elsewhere encoding end endassociate endblockdata enddo \
endfile endforall endfunction endif endinterface endmodule endprogram \
endselect endsubroutine endtype endwhere entry eor equivalence \
err errmsg exist exit external file flush fmt forall form format \
formatted function go goto id if implicit in include inout \
integer inquire intent interface intrinsic iomsg iolength \
iostat kind len logical module name named namelist nextrec nml \
none nullify number only open opened operator optional out pad \
parameter pass pause pending pointer pos position precision \
print private procedure program protected public quote read readwrite \
real rec recl recursive result return rewind save select \
selectcase selecttype sequential sign size stat status stop stream \
subroutine target then to type unformatted unit use value \
volatile wait where while write

keywords.$(file.patterns.f95)=$(keywordclass.fortran)
keywords.$(file.patterns.f77)=$(keywordclass.fortran)

# keywords2 is for highlighting intrinsic and extended functions
keywords2.$(file.patterns.fortran)=abs achar acos acosd adjustl adjustr \
aimag aimax0 aimin0 aint ajmax0 ajmin0 akmax0 akmin0 all allocated alog \
alog10 amax0 amax1 amin0 amin1 amod anint any asin asind associated \
atan atan2 atan2d atand bitest bitl bitlr bitrl bjtest bit_size bktest break \
btest cabs ccos cdabs cdcos cdexp cdlog cdsin cdsqrt ceiling cexp char \
clog cmplx conjg cos cosd cosh count cpu_time cshift csin csqrt dabs \
dacos dacosd dasin dasind datan datan2 datan2d datand date \
date_and_time dble dcmplx dconjg dcos dcosd dcosh dcotan ddim dexp \
dfloat dflotk dfloti dflotj digits dim dimag dint dlog dlog10 dmax1 dmin1 \
dmod dnint dot_product dprod dreal dsign dsin dsind dsinh dsqrt dtan dtand \
dtanh eoshift epsilon errsns exp exponent float floati floatj floatk floor fraction \
free huge iabs iachar iand ibclr ibits ibset ichar idate idim idint idnint ieor ifix \
iiabs iiand iibclr iibits iibset iidim iidint iidnnt iieor iifix iint iior iiqint iiqnnt iishft \
iishftc iisign ilen imax0 imax1 imin0 imin1 imod index inint inot int int1 int2 int4 \
int8 iqint iqnint ior ishft ishftc isign isnan izext jiand jibclr jibits jibset jidim jidint \
jidnnt jieor jifix jint jior jiqint jiqnnt jishft jishftc jisign jmax0 jmax1 jmin0 jmin1 \
jmod jnint jnot jzext kiabs kiand kibclr kibits kibset kidim kidint kidnnt kieor kifix \
kind kint kior kishft kishftc kisign kmax0 kmax1 kmin0 kmin1 kmod knint knot kzext \
lbound leadz len len_trim lenlge lge lgt lle llt log log10 logical lshift malloc matmul \
max max0 max1 maxexponent maxloc maxval merge min min0 min1 minexponent minloc \
minval mod modulo mvbits nearest nint not nworkers number_of_processors pack popcnt \
poppar precision present product radix random random_number random_seed range real \
repeat reshape rrspacing rshift scale scan secnds selected_int_kind \
selected_real_kind set_exponent shape sign sin sind sinh size sizeof sngl snglq spacing \
spread sqrt sum system_clock tan tand tanh tiny transfer transpose trim ubound unpack verify

# keywords3 are nonstardard, extended and user defined functions
keywords3.$(file.patterns.fortran)=cdabs cdcos cdexp cdlog cdsin cdsqrt cotan cotand \
dcmplx dconjg dcotan dcotand decode dimag dll_export dll_import doublecomplex dreal \
dvchk encode find flen flush getarg getcharqq getcl getdat getenv gettim hfix ibchng \
identifier imag int1 int2 int4 intc intrup invalop iostat_msg isha ishc ishl jfix \
lacfar locking locnear map nargs nbreak ndperr ndpexc offset ovefl peekcharqq precfill \
prompt qabs qacos qacosd qasin qasind qatan qatand qatan2 qcmplx qconjg qcos qcosd \
qcosh qdim qexp qext qextd qfloat qimag qlog qlog10 qmax1 qmin1 qmod qreal qsign qsin \
qsind qsinh qsqrt qtan qtand qtanh ran rand randu rewrite segment setdat settim system \
timer undfl unlock union val virtual volatile zabs zcos zexp zlog zsin zsqrt

#fold.comment.fortran=1
#fold.quotes.fortran=1

comment.block.fortran=!~

# These setting do not work very well for FORTRAN, uncoment to use it
# statement.indent.$(file.patterns.fortran)=8 associate block blockdata case do enum \
# 	function interface module program subroutine then type where

# Fortran styles
# Default
style.fortran.0=fore:#808080
style.f77.0=fore:#808080
style.fortran.32=
style.f77.32=
# Comment
style.fortran.1=$(colour.code.comment.line),$(font.code.comment.line)
style.f77.1=$(colour.code.comment.line),$(font.code.comment.line)
# Number
style.fortran.2=$(colour.number)
style.f77.2=$(colour.number)
# Single quoted string
style.fortran.3=$(colour.string)
style.f77.3=$(colour.string)
# Double quoted string
style.fortran.4=$(colour.string)
style.f77.4=$(colour.string)
# End of line where string is not closed
style.fortran.5=fore:#000000,back:#E0C0E0,eolfilled
style.f77.5=fore:#000000,back:#E0C0E0,eolfilled
# Operators
style.fortran.6=$(colour.operator),bold
style.f77.6=$(colour.operator),bold
# Identifiers
style.fortran.7=
style.f77.7=
# Keywords
style.fortran.8=$(colour.keyword),case:u
style.f77.8=$(colour.keyword),case:u
# Keywords2
style.fortran.9=fore:#B00040
style.f77.9=fore:#B00040
# Keywords3
style.fortran.10=fore:#B04080
style.f77.10=fore:#B04080
# Preprocessor
style.fortran.11=$(colour.preproc)
style.f77.11=$(colour.preproc)
# Operators in .NAME. format
style.fortran.12=$(colour.operator),bold
style.f77.12=$(colour.operator),bold
# Labels
style.fortran.13=fore:#E0C0E0
style.f77.13=fore:#E0C0E0
# Continuation
style.fortran.14=fore:#000000,back:#F0E080
style.f77.14=fore:#000000,back:#F0E080
# Braces are matched in all cases
braces.fortran.style=0

if PLAT_WIN
	fc77=lf95 $(FileNameExt) -c -fix
	fc90=lf95 $(FileNameExt) -c
if PLAT_GTK
	fc77=f77 -c -o $(FileName).o $(FileNameExt)
	fc90=f90 -c -o $(FileName).o $(FileNameExt)

command.compile.*.f=$(fc77)
command.build.*.f=make
command.go.*.f=$(FileName)

command.compile.*.for=$(fc77)
command.build.*.for=make
command.go.*.for=$(FileName)

command.compile.*.f90=$(fc90)
command.build.*.f90=make
command.go.*.f90=$(FileName)

command.compile.*.f95=$(fc90)
command.build.*.f95=make
command.go.*.f95=$(FileName)

if PLAT_WIN
    api.$(file.patterns.fortran)=$(SciteDefaultHome)\fortran.api

autocomplete.fortran.ignorecase=1
autocomplete.f77.ignorecase=1
calltip.fortran.ignorecase=1
calltip.f77.ignorecase=1
################################################################################
# end of the properties file                                                   #
################################################################################
